---
title: "30. User generated client API keys"
date: 2024-02-22T15:30:00+01:00
weight: 30
geekdocRepo: https://github.com/owncloud/ocis
geekdocEditPath: edit/master/docs/ocis/adr
geekdocFilePath: 0030-user-generated-client-api-keys.md
---

* Status: draft
* Deciders: [@butonic](https://github.com/butonic), [@fschade](https://github.com/fschade), [@kulmann](https://github.com/kulmann), [@dragotin](https://github.com/dragotin), [@rhafer](https://github.com/rhafer)
* Date: 2024-02-22

## Context and Problem Statement

Currently, the oCIS proxy is used to authenticate users based on an OpenID Connect access token or using basic auth.
The current implementation is limited to a single identity provider, and we currently have no way to generate credentials for cli tools that do not yet support OpenID Connect

The coming up calendar and contacts service requires this because most CalDAV and CardDAV clients require basic or digest authentication.

## Decision Drivers <!-- optional -->

## Considered Options

* oCIS proxy middleware with micro store

## Decision Outcome

Chosen option: *???*

### Positive Consequences:

* TODO

### Negative Consequences:

* TODO

## Pros and Cons of the Options <!-- optional -->

### oCIS proxy middleware with micro store

We use a micro store implementation to save generated access keys.
Generated access keys will have a scope attached to limit access to oCIS services or endpoints.

These scopes need to be defined - for ccs it would be sufficient to use /ccs/ endpoint.

The generated access keys need to be entered into classic authentication forms which consist of user and password.
Both elements need to be provided/generated by oCIS to the user.

There will be a web frontend where users can:
- create a new pair of user and password(key) for selected scopes and give some display name.
- list existing keys with display name, scope, user (but not the password - or shall we???)
- delete a key from the list

Within oCIS backend an authentication middleware will evaluate http authentication headers with schema basic and look up if the request is valid.

#### Key generation
The key id is a uuid. It will be used as ID in basic auth
Upon creation the backend generates a JWT holding the generated key id, the scope and the oCIS user identification information.
As key secret the signature part of the JWT is handed out to the user.


```json
{
  "sub": "163463be-f070-4097-8c79-42ceac20eb1b",
}
```

The payload above with generate a JWT similar to this:
```jwt
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxNjM0NjNiZS1mMDcwLTQwOTctOGM3OS00MmNlYWMyMGViMWIifQ.PKJqy3xyZzk3hpNOLo7gqoAqt-QVDofrJ5RDEdQ-8ZU
```

The signature is the last segment: ```PKJqy3xyZzk3hpNOLo7gqoAqt-QVDofrJ5RDEdQ-8ZU```

### Authentication
Key id and key secret will be read from the http authentication header and the JWT is reconstructed with the given key id.
The JWT's signature is compared to the key secret.
If the signatures do not match we can deny access without hitting any storage which limits the dos capabilities.
If the signatures match:
- read scope and oCIS user data from micro store
- validate user to be enabled and still existing
- validate scope
- grant access if aplicable


- Good, invented by us :dancers:
- Bad, ???



## Links <!-- optional -->
